# Node.JS com Expressüî•

Esse reposit√≥rio √© um breve resumo, com as principais informa√ß√µes retiradas do m√≥dulo 2 do curso [JSTACK](https://jstack.com.br/).

---
## Get in touch
Feito com ‚ù§Ô∏è by [**Milton Soares**](https://www.linkedin.com/in/soaresmilton/)

[![Linkedin Badge](https://img.shields.io/badge/linkedin-%230077B5.svg?&style=for-the-badge&logo=linkedin&logoColor=white&link=https://www.linkedin.com/in/soaresmilton/)](https://www.linkedin.com/in/soaresmilton/)
[![Youtube Badge](https://img.shields.io/badge/youtube-%23FF0000.svg?&style=for-the-badge&logo=youtube&logoColor=white)](https://www.youtube.com/channel/UCMsbUh0LDOMQCTBdBXwkFiQ/)
[![Instagram Badge](https://img.shields.io/badge/instagram-%23E4405F.svg?&style=for-the-badge&logo=instagram&logoColor=white&link=https://www.instagram.com/soaresmiltinho/)](https://www.instagram.com/soaresmiltinho/)
---

## Objetivo

Com a evolu√ß√£o do m√≥dulo, quero utilizar os conceitos aprendidos para desenvolver meu projeto chamado [getBooks](https://github.com/soaresmilton/getbooks)

---

### üìå√çndice

1. [Package Managers ‚Üí yarn and npm](#aula-1)

2. [Criando um servidor http com Express](#aula-2)

3. [Instalando o Nodemon](#aula-3)

4. [npm scripts](#aula-4)

5. [Configurando o Eslint e o editorconfig](#aula-5)

6. [Criando Controller de Contatos](#aula-6)

7. [Entendendo o Repository Pattern](#aula-7)

8. [Criando Repository de Contatos](#aula-8)

9. [Criando as rotas de show e delete](#aula-9)

10. [O que s√£o Middlewares?](#aula-10)

11. [Criando a rota de cadastro de Contatos](#aula-11)

12. [Criando a rota de edi√ß√£o dos Contatos](#aula-12)

13. [Pr√≥ximos passos](#aula-13)

14. [O que √© o Docker?](#aula-14)

15. [Instalando o Docker](#aula-15)

16. [Comandos B√°sicos do Docker](#aula-16)

17. [Preparando o Banco de Dados](#aula-17)

18. [Criando a tabela de Contatos](#aula-18)

19. [Conectando o Node ao Postgres](#aula-19)

20. [Refatorando o m√©todo create](#aula-20)

21. [Refatorando os m√©todos de find](#aula-21)

22. [Ordenando os resultados do SELECT](#aula-22)

23. [Refatorando o m√©todo update](#aula-23)

24. [Refatorando o m√©todo delete](#aula-24)

25. [Criando o m√≥dulo de Categorias](#aula-25)

26. [Trabalhando com JOINS](#aula-26)

27. [Capturando e tratando erros](#aula-27)

---

# Aula 1

## Package Managers - Npm and Yarn

### Tipos de m√≥dulo do Node.JS

- Nativos (ex.: *http, fs, os, URL*);
- Arquivos criados JavaScript;
- Node Package Manager (npm).

Instalando o node, j√° se instala o npm automaticamente.

O [Yarn](https://yarnpkg.com/) tamb√©m √© um Package Manager. Por√©m, com algumas funcionalidades melhoradas em rela√ß√£o ao NPM, tais como efici√™ncia na instala√ß√£o de pacotes e o arquivo *yarn.lock* que garante estabilidade em vers√µes futuras da aplica√ß√£o. Vale ressaltar que, atualmente, o npm tamb√©m tem a funcionalidade lock em suas features.

---

# Aula 2

## Criando um servidor http com Express

O objetivo dessa aula √© dar in√≠cio ao desenvolvimento da nossa API, que ser√° a base para a primeira aplica√ß√£o do curso, o **myContacts**. Para essa API, iremos utilizar alguns pacotes (ex.: express), que nos auxiliar√° na constru√ß√£o da API.

### Iniciando:

Para iniciar qualquer projeto node: `npm init -y` ou `yarn init`

**Instalando o express:**

`yarn add express`

### Desenvolvimento da aplica√ß√£o

1. `mkdir src && cd src && touch index.js`
2. Iniciar o servidor express. O nosso arquivo *index.js*:

    ```jsx
    const express = require('express');
    const app = express();

    const PORT = 3000;

    app.get('/', (request, response) => {
      response.send('<h1>Hello World</h1>')
    })

    app.listen(PORT, () => {
      console.log(`SERVER IS RUNING AT ===> http://localhost:${PORT}`);
    })
    ```

---

# Aula 3

## Instalando o Nodemon

O Nodemon √© um pacote de desenvolvimento, que nos auxilia na produtividade de constru√ß√µes de aplica√ß√£o com o Node.

Ele, por sua vez, fica "ouvindo" nosso servidor, fazendo com que n√£o precisemos reiniciar o servidor sempre que quisermos ver uma altera√ß√£o implementada.

**Instalando o nodemon como depend√™ncia de desenvolvimento:**

`yarn add nodemon -D`  ou `npm install nodemon -D`

**Usando o nodemon:**

`npx nodemon src/index.js`

---

# Aula 4
## Npm scripts

Os *npm's scripts* servem, basicamente, para duas coisas:

1. Fazer automa√ß√µes para processos e tarefas repetitivas
2. Atalhos para comandos longos e chatos de escrever

### Entendendo automa√ß√µes com npm scripts:

Para criar um novo npm script:

- No arquivo *package.json* criar um novo nodo chamado "scripts". Dentro desse nodo, especificar a chave, que ser√° o comando acionador do script e o valor dessa chave ser√° o comando node executado.
- No c√≥digo abaixo, vamos criar um script para iniciar nosso servidor.

```json
{
  "name": "express",
  "version": "1.0.0",
  "main": "index.js",
  "repository": "https://github.com/soaresmilton/api-express.git",
  "author": "Milton Soares <eng.milton.soares@gmail.com>",
  "license": "MIT",

  "scripts": {
    "dev": "nodemon src/index.js"
  },

  "dependencies": {
    "express": "^4.17.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.14"
  }
}

```

- No caso, o script substitui todo o comando: `nodemon src/index.js`, que n√≥s est√°vamos utilizando para iniciar um servidor, por `yarn dev` ou `npm run dev`.

---

# Aula 5
## Configurando o Eslint e o editorconfig

O Eslint √© uma ferramenta desenvolvida para padronizar a forma que escrevemos o c√≥digo, para manter ele limpo, organizado e padronizado ao longo do tempo. Esse tipo de ferramenta, garante que iremos ter consist√™ncia na digita√ß√£o do nosso c√≥digo, de forma a garantir, por exemplo, que sempre colocaremos ;, ou utilizaremos aspas simples para manusear strings.

**Iniciando a configura√ß√£o:**

1. Instalar a extens√£o ESLint no VSCODE
2. Instalar o pacote do ESLint no projeto:
    1. `yarn add eslint -D`
3. Acionar o comando de inicializa√ß√£o da ferramenta: `yarn eslint --init`. Ap√≥s executar o comando, algumas perguntas apareceram para a configura√ß√£o. Para esse projeto, responderemos:
    1. pergunta 1: Op√ß√£o 3
    2. Pergunta 2: Op√ß√£o 2
    3. Pergunta 3: Op√ß√£o 3
    4. Pergunta 4: No
    5. Pergunta 5: Node ‚Üí Primeiro apertar a tecla espa√ßo para desmarcar a op√ß√£o "browser" e selecionar a op√ß√£o Node para continuar.
    6. Pergunta 6: Op√ß√£o 1
    7. Pergunta 7: Op√ß√£o 1 - Style Guide do Airbnb
    8. Pergunta 8: Op√ß√£o 1
    9. Pergunta 9: yes

    Ap√≥s a configura√ß√£o, rodar o comando yarn no terminal para o Yarn reconhecer o eslint tamb√©m.


### Editorconfig

A segunda ferramenta de configura√ß√µes que iremos utilziar √© o EditorConfig for VS Code. Da mesma forma, devemos instalar essa extens√£o no nosso editor de texto.

**Usando o editorconfig**

1. Na parte *explorer,* onde mostra a estrutura de arquivos do nosso editor de texto, clicar com o bot√£o direito do mouse e selecionar a op√ß√£o: ***Generate .editorconfig***
2. Isso vai criar um documento *.editorconfig* com algumas configura√ß√µes pr√© determinadas

    ```jsx
    # EditorConfig is awesome: https://EditorConfig.org

    # top-most EditorConfig file
    root = true

    [*]
    indent_style = space
    indent_size = 2
    end_of_line = lf
    charset = utf-8
    trim_trailing_whitespace = true //vem false como padr√£o
    insert_final_newline = true // vem false como padr√£o
    ```

---

# Aula 6

## Criando Controller de Contatos

**Defini√ß√£o de controller**

Um *controller* atua como um centralizador de funcionalidades ou regras de neg√≥cio de uma determinada entidade de nossa aplica√ß√£o.

Como a API a ser constru√≠da ser√° relacionados a gerenciamento de contatos, portanto iremos criar um controller espec√≠fico para os contatos.

**Iniciando nossa estrutura:**

- Em src, criar uma pasta app, em app criar a pasta controllers.
    - A pasta controllers ser√° nosso local de cria√ß√£o dos controllers para cada entidade que nossa aplica√ß√£o necessitar;
    - Resumindo: `cd src && mkdir app && cd app && mkdir controllers && cd controllers && touch ContactController.js`

    Estrutura de pastas nesse ponto da aplica√ß√£o:

    ![Arquitetura de pastas do nosso projeto at√© o momento](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a636e647-87c9-402a-a01d-039740a3cf8e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20211028%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211028T010122Z&X-Amz-Expires=86400&X-Amz-Signature=c6847af7944c723aba3ba1188bb9187182eef8b5b8a9980c55049120a58fa1e2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)


    Arquitetura do nosso projeto at√© o momento. Destacando o controller criado

- Nos controllers, vamos implement√°lo utilizando classes e iremos utilizar um Design Pattern chamado de Singleton. Esse pattern diz que podemos ter apenas uma √∫nica instancia do objeto em nosso app.
- Para os m√©todos da nossa classe referente ao Controller, iremos abordar seus m√©todos usando uma conven√ß√£o padr√£o, em que os m√©todos:
    - index() ‚áí Usado para listar todos os registros do Controller;
    - show() ‚áí Usado para obter somente um registro;
    - store() ‚áí Cria novo registro
    - update() ‚áí Edita um registro
    - delete() ‚áí Deleta um registro
- Continuando ‚áí Mover nossas rotas criadas no arquivo *index.js*  para um novo arquivo chamado *routes.js* criado dentro da pasta src.

    Nosso arquivo routes.js dever√° ficar dessa maneira:

    ```jsx
    const { Router } = require('express');
    const router = Router();
    const ContactController = require('./app/controllers/ContactController');

    router.get('/contacts', ContactController.index);

    module.exports = router;
    ```

    O arquivo index.js:

    ```jsx
    const express = require("express");
    const routes = require('./routes');
    const app = express();

    const PORT = 3000;

    app.use(routes);

    app.listen(PORT, () => {
      console.log(`SERVER IS RUNING AT ===> http://localhost:${PORT}`);
    });
    ```

    O arquivo ContactController.js

    ```jsx
    class ContactController {
      index(request, response) {
        //lista todos os registros
        response.send('Sendo from Contact Controller')
      }

      show() {
        //obter um registro
      }

      store() {
        //Criar novo registro
      }

      update() {
        //Editar um registro
      }

      delete() {
        // Deletar um registro
      }
    }

    //Design Pattern: Singleton => Podemos ter apenas uma √∫nica inst√¢ncia desse objeto no app
    module.exports = new ContactController();
    ```

---

# Aula 7

## Entendendo o Repository Pattern

**Defini√ß√£o:**
Repository Pattern √© uma layer (camada) de abstra√ß√£o de acesso ao Data Source (fonte de dados, que pode ser: SQL, NoSQL, .json, API).

**Vantagens de usar o Repository Pattern:**

O repository pattern tira a obriga√ß√£o de implementar dados sens√≠veis, como a regra de neg√≥cio principal da aplica√ß√£o, dentro de um controller. Consequentemente, deixa o c√≥digo mais f√°cil de se manter a longo prazo, bem como seguro contra erros de l√≥gica e implementa√ß√£o.

Exemplo: caso em algum momento do desenvolvimento da aplica√ß√£o, necessite trocar o banco de dados SQL para um NoSQL, podemos refatorar somente o repository, sem fazer altera√ß√µes sens√≠veis no controller

Dessa forma, a arquitetura b√°sica desse pattern fica:

`Controller ‚Üî Repository ‚Üî Data Source`

Sendo assim, o Controller n√£o tem interesse em como o repository ir√° criar seus m√©todos para cria√ß√£o de entidades dentro da aplica√ß√£o.

---

# Aula 8

## Criando Repository de Contatos

**Iniciando:**

- Criar pasta *repositories* dentro da pasta app.
- Criar arquivo repository da entidade em quest√£o. Nesse caso, criar o arquivo *ContactRepository.*
- Nessa aplica√ß√£o, tamb√©m iremos usar o pattern Singleton para exportar o ContactRepository como uma classe instanciada.
- Na classe instanciada, iremos criar todos os m√©todos que o repository necessita para manipular o data source.
- Iremos iniciar a aplica√ß√£o com um Data Source mocado, para que futuramente, possamos entender o sentido de usar o Repository Pattern na pr√°tica, refatorando o repository e migrando o Data Source para o PostgreSQL
- Instalar a lib *uuidv4* para gerar hashs para nosso ID ser uma string alfanum√©rica ‚Üí melhora a seguran√ßa de nossos dados; `yarn add uuid`
- Cria o mock no proprio arquivo do repository, sendo que o mock √© um array de objetos.
- Agora, implementamos uma l√≥gica bem simples para retornar a lista de contatos: criar metodo findAll em nossa classe **ContactRepository** que simplesmenre retorna os contatos. Ap√≥s isso, importar o repository no controller e chamar o m√©todo ContactRepository.findAll() no m√©todo index();

    Nesse ponto, nossos arquivos *ContactRepository.js* e *ContactRepository.js* ficaram dessa maneira:

    *ContactRepository:*

    ```jsx
    const { uuid } = require('uuidv4');
    const contacts = [
      {
        id: uuid(),
        name: 'Milton',
        email: 'milton@gmail.com',
        phone: '3555555555',
        category_id: uuid(),
      },
    ]

    class ContactRepository {
      // Listar todos os registros do reposit√≥rio
      findAll() {
        return contacts;
      }
    }

    module.exports = new ContactRepository();
    ```

    *ContactRepository:*

    ```jsx
    const ContactRepository = require('../repositories/ContactRepository');

    class ContactController {
      async index(request, response) {
        //lista todos os registros
        const contacts = await ContactRepository.findAll();
        response.json(contacts);
      }

      show() {
        //obter um registro
      }

      store() {
        //Criar novo registro
      }

      update() {
        //Editar um registro
      }

      delete() {
        // Deletar um registro
      }
    }

    //Design Pattern: Singleton => Podemos ter apenas uma √∫nica inst√¢ncia desse objeto no app
    module.exports = new ContactController();
    ```

- Nesse ponto √© importante observar que, quando tivermos conectados a um banco de dados, a chamada dos dados do banco para que seja poss√≠vel listar os contatos na tela, √© uma fun√ß√£o bloqueante devido ao tempo de resposta do banco de dados. Ent√£o, temos que transformar o m√©todo findAll em uma promise JS e utilizar o conceito de async / await no m√©todo index() do Contact Controller.  Veja na pr√°tica:


    ```jsx
    const { v4 } = require('uuidv4');
    const contacts = [
      {
        id: v4(),
        name: 'Milton',
        email: 'milton@gmail.com',
        phone: '3555555555',
        category_id: v4(),
      },
    ]

    class ContactRepository {
      // Listar todos os registros do reposit√≥rio
      findAll() {
        return new Promise((resolve) => resolve(contacts));
      }
    }

    module.exports = new ContactRepository();
    ```

---

# Aula 9

## Criando as rotas de show e delete

Nessa aula iremos implementar os m√©todos show e delete. Aprenderemos a como receber par√¢metros nas rotas com o express e dar continuidade no desenvolvimento de nossa API.

**M√©todo SHOW:**

- No arquivo routes.js, criar a rota para o show. Nesse ponto, nosso arquivo de rotas vai ficar dessa maneira:

    ```jsx
    const { Router } = require('express');
    const router = Router();
    const ContactController = require('./app/controllers/ContactController');

    router.get('/contacts', ContactController.index);
    router.get('/contacts/:id', ContactController.show);

    module.exports = router;
    ```

- Uma vez criado a rota que recebe o param desejado na URL, podemos implementar os m√©todos no Controller e no repository. Para o Controller, por conven√ß√£o, implementaremos o m√©todo *show()*. A implementa√ß√£o desse m√©todo fica:

    ```jsx
    async show(request, response) {
        //obter um registro
        const { id } = request.params;
        const contact = await ContactRepository.findById(id);

        if (!contact) return response.status(404).json({ error: 'Contact not found' });

        response.json(contact);
      }
    ```

- Agora, devemos impelemntar o m√©todo **findById()** dentro do nosso repository. √â esse m√©todo que de fato encontra o contato pelo seu ID. Aqui, j√° conseguimos enchergar melhor um pouco mais da ideia por tr√°s o Repository Pattern. Sendo assim, a implementa√ß√£o do m√©todo *findById()* fica:

    ```jsx
    findById(id) {
        return new Promise((resolve) => resolve(
          contacts.find((contact) => contact.id === id)
        ));
      }
    ```


**M√âTODO DELETE:**

- Criar rota delete no arquivo de rotas;

    ```jsx
    router.delete('/contacts/:id', ContactController.delete);
    ```

- Implementar o m√©todo delete no Controller

    ```jsx
    async delete(request, response) {
        // Deletar um registro
        const { id } = request.params;

        const contact = await ContactRepository.findById(id);
        if (!contact) return response.status(404).json({ error: 'Contact not found' });

        await ContactRepository.delete(id);
        response.sendStatus(204); // 204: No content
      }
    ```

- Implementar o m√©todo delete do Repository:

    ```jsx
    delete(id) {
        return new Promise((resolve) => {
          contacts  = contacts.filter((contact) => contact.id !== id)
          resolve();
        })
      }
    ```

---

# Aula 10
## O que s√£o Middlewares?

**Como funciona o life cycle de uma request:**

Toda vez que uma request "chega" a API precisa resolver essa requisi√ß√£o. E pra resolver essa requisi√ß√£o n√≥s chamamos um m√©todo de um Controller, que √© onde est√° localizado nossa regra de neg√≥cio. Ao fim da resolu√ß√£o de nossa request, n√≥s respondemos alguma coisa, enviando uma response (seja um sucesso ou um erro).

>Request ‚Üí Repository ‚Üí Controller ‚Üí response

**Com os Middlewares**

Os middlewares,  manipulam os objetos *request* e *response*. Fazendo todas as a√ß√µes necess√°rias nesses objetos, inclusive inserindo novas propriedades a eles e disponibilizando para todos os controllers  da aplica√ß√£o. Ou at√© mesmo executando para coisas espec√≠ficas para uma determinada rota ou determinado controller.

Outra funcionalidade dos middlewares √© poder controlar o life cycle do request. Como assim?

Essencialmente,  os middlewares antecipam uma request, antes dessa request chegar ao Controller. Dessa forma, os middlewares conseguem responder alguma coisa para a request caso seja necess√°rio. Sendo assim, conseguem decidir se a request continuar√° o caminho de execu√ß√£o "normal", sendo enviada para o Controller resolver a request ou se a requisi√ß√£o ser√° interrompida e alguma resposta ser√° retornada para a pr√≥pria request.

>Request ‚Üî Repository ‚Üí Controller - response

**Caso de uso commum:**

- Autentica√ß√£o ‚Üí valida√ß√£o de usu√°rio.

---

# Aula 11
## Criando a rota de cadastro de Contatos

- Primeiro passo criar rota com m√©todo POST no arquivo routes.js:

    ```jsx
    router.post('/contacts', ContactController.store);
    ```

- Chamar o m√©todo (middleware) json no arquivo index.js:

    ```jsx
    app.use(json());
    ```

- Implementar os m√©todos que ir√£o fazer o registro das informa√ß√µes. Nesse caso, no Controller, o m√©todo usado executar a cria√ß√£o de contatos √© o store(). No Repository, os m√©todos utilizados s√£o chamados de findByEmail() - que verifica se o email j√° foi cadastrado anteriormente e o create() ‚Üí que necessariamente √© usado para criar o contato.

    **M√©todo store() ‚Üí no Controller**

    ```jsx
    async store(request, response) {
        //Criar novo registro
        const { name, email, phone, category_id } = request.body;

        if(!name) {
          return response.status(400).json({ error: 'Name is required' });
        }

        const contactExists = await ContactRepository.findByEmail(email);
        if (contactExists) {
          return response.status(400).json({ error: 'This email already been taken' })
        }

        const contact = await ContactRepository.create({
          name, email, phone, category_id
        });

        response.json(contact)
      }
    ```

    **M√©todo findByEmail() - No Repository:**

    ```jsx
    findByEmail(email) {
        return new Promise((resolve) => resolve(
          contacts.find((contact) => contact.email === email)
        ));
      }
    ```

    **M√©todo create() - no repository**

    ```jsx
    create({name, email, phone, category_id}) {
        return new Promise((resolve) => {
          const newContact = {
            id: v4(),
            name,
            email,
            phone,
            category_id: v4()
          }

          contacts.push(newContact)
          resolve(newContact);
        })
      }
    ```
---

# Aula 12

## Criando a rota de edi√ß√£o dos Contatos

Para finalizarmos a primeira parte de nossa API, falta construir nossa rota de edi√ß√£o de contatos.

Para isso, seguimos:

- Criando a rota com m√©todo HTTP do tipo PUT. em *routes.js*:

```jsx
router.put('/contacts/:id', ContactController.update);
```

- Implementando o m√©todo update no Controller. Em *ContactController.js:*

```jsx
async update(request, response) {
    //Editar um registro
    const { id } = request.params;
    const { name, email, phone, category_id } = request.body;

    const contactExists = await ContactRepository.findById(id);
    if (!contactExists) return response.status(404).json({ error: 'User not found' });

    if (!name) return response.status(400).json({ error: 'Name is required' });

    const contactByEmail = await ContactRepository.findByEmail(email);
    if (contactByEmail && contactByEmail.id !== id) return response.status(400).json({ error: 'This e-mail is already in use' });

    const contact = await ContactRepository.update(id, {
      name, email, phone, category_id
    });

    response.json(contact);
  }
```

- Implementar o m√©todo update no Repository: Em *ContactRepository.js:*

```jsx
update(id, {
    name, email, phone, category_id,
  }) {
    return new Promise((resolve) => {
      const updatedContact = {
        id,
        name,
        email,
        phone,
        category_id,
      };

      contacts = contacts.map((contact) => (
        contact.id === id ? updatedContact : contact
      ));

      resolve(updatedContact);
    });
  }
```

---

# Aula 13

## Pr√≥ximos passos

Agora que nossas rotas da API est√£o constru√≠das e funcionando, podemos dar um passo al√©m na constru√ß√£o de nossa aplica√ß√£o.

Portanto, podemos refatorar nossos repositories, desfazendo dos dados em mem√≥ria que constru√≠mos atrav√©s de um mock.

Nas pr√≥ximas aulas iremos entender o conceito de DOCKER e conectar nossa aplica√ß√£o em um banco de dados PostgreSQL.

---

# Aula 14

## O que √© docker?

Docker √© uma *[container engine](https://www.docker.com/resources/what-container)* muito utilizada para trabalhar com a ideia de virtualiza√ß√£o de imagens dentro de um host, poupando recursos e disponibilizando solu√ß√µes para atua√ß√£o de v√°rios servi√ßos integrados, sem se preocupar com atualiza√ß√µes de libs ou bin√°rios espec√≠ficos.

O Docker, portanto, viabiliza o uso de VMs dentro de um host (AWS por exemplo) para rodar diferentes partes de nossa aplica√ß√£o (uma VM para o Node na vers√£o X outra VM para o node na vers√£o Y e outra VM para o postgreSQL na vers√£o Z) utilizando o kernel do Host, por√©m, cada qual em sua pr√≥pria VM com suas libs e bins.

![Imagem explicativa do funcionamento do docker](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2d46ee47-8b70-41c8-80d7-ecb620e59570/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20211104%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211104T180132Z&X-Amz-Expires=86400&X-Amz-Signature=f5c83da13efad1db91236bf8bf9e447ae1872256223f803d6a89801a42b9bf22&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

### Por que usar Containers?

- As aplica√ß√µes rodam de forma isolada (n√£o interferem uma na outra);
- Usa o mesmo Kernel da m√°quina base, tornando-se mais leve e eficiente quando comparado √†s VM's tradicionais;
- Portabilidade ‚Üí atrav√©s dos containers conseguimos compartilhar o ambiente onde nossa aplica√ß√£o roda, com as exatas caracter√≠sticas que a aplica√ß√£o necessita para funcionar da maneira correta naquele momento.


---

# Aula 15
## Instalando o Docker

Para a instala√ß√£o, basta seguir o passo a passo na documenta√ß√£o no pr√≥prio site do [Docker](https://www.docker.com/).

---

# Aula 16

## Comandos b√°sicos do Docker

Essa aula aborda os comandos b√°sicos e mais usados do Docker.

Via de regra, a primeira coisa a se fazer √© baixar a imagem que iremos utilizar, para depois criar o cont√™iner:

- `sudo docker pull postgres` ‚áí baixa a imagem do postgres
- `sudo docker image ls` ‚áí lista todas as imagens baixadas
- `sudo docker run --name pg -e POSTGRES_USER=root -e POSTGRES_PASSWORD=root -p 5432:5432 -d postgres` ‚áí Cria o container com base na imagem baixada. As flags: - -name: define um nome para o container, -e: define as vari√°veis de ambiente que a gente quiser ter, nesse caso temos as que definem o usu√°rio e senha do DB, -p: define a porta de uso, no caso do postgres a sua porta padr√£o √© a 5432, portanto iremos utiliz√°-la, por fim, a flag -d: nome da imagem que iremos rodar dentro do container, portanto √© atrav√©s dessa tag que definimos a imagem ‚Üí container. == Ap√≥s rodar esse comando, ser√° gerado uma hash (nesse caso: 5d7c2a46d169c679235ca6edc9a47bfae7a93a8865ef7639a145f9b755ed67be), que indica que o container foi criado
- `sudo docker container ls` ou `sudo docker ps`‚áí lista os containers
- `sudo docker stop <CONTAINE_NAME>` ou `sudo docker stop <CONTAINER_ID>` ‚áí para de executar o container, por√©m n√£o exclui esse container
- `sudo docker ps -a` ou `sudo docker container ls -a` ‚áí lista todos os containers criados, incluindo os containers que n√£o est√£o ativos
- `sudo docker start <CONTAINER_NAME>` ou `sudo docker start <CONTAINER_ID>` ‚áí inicia o reposit√≥rio que estava inativo ou 'stopado'
- `sudo docker rm -f <CONTAINER_ID>` ou `sudo docker container rm <CONTAINER_NAME>` ‚áí remove/exclui o container docker. Antes de excluir um container, √© necess√°rio stopar ele, executando o comando do passo 2.
- `sudo docker rmi <IMAGE_NAME>` ou `sudo docker rmi <IMAGE_ID>` ‚áí Exclui a **IMAGEM.** Por√©m, antes de deletar uma imagem, temos que parar o(s) container(s) que est√° rodando com essa imagem, apagar o container e assim apagar a imagem.
---

# Aula 17

## Preparando o Banco de Dados

- Em src ‚áí criar folder database
- Em database ‚áí criar file schema.sql
- Verificar se o container do banco de dados est√° funcionando:  `sudo docker ps` se n√£o estiver, ativar com o `sudo docker start <CONTAINER_NAME>`
- Executar o container: `sudo docker exec -it <CONTAINER_NAME> bash`
- Ap√≥s entrar no terminal do container, executando o container, vamos logar no postgres com o seguinte c√≥digo: `psql -U <POSTGRES_USER>` nesse caso POSTGRES_USER == root

### Alguns comandos b√°sicos do POSTGRES

- `\l`  ‚áí lista a base de dados criada
- `CREATE DATABASE <nome_do_banco>;` ‚áí Query para criar tabela em banco de dados SQL;
- `\c <nome_do_banco>` ‚áí conecta ao banco de dados criado
- `CREATE TABLE <nome_da_tabela> ();`  ‚áí Cria tabelas no SQL
- `\dt` ‚áí lista todas as tabelas criadas dentro do banco
- `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";` ‚áí Cria uma extens√£o que acessa a fun√ß√£o para gerar UUIDs no postgres. Observar que: essa extens√£o s√≥ ser√° criada se el√° n√£o existir no banco

---

# Aula 18
## Criando tabela de Contatos

- Criar tabela de contatos em schema.sql

```sql
CREATE DATABASE mycontacts;

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE IF NOT EXISTS categories (
  id UUID NOT NULL UNIQUE DEFAULT uuid_generate_v4(),
  name VARCHAR NOT NULL
);

CREATE TABLE IF NOT EXISTS contacts (
  id UUID NOT NULL UNIQUE DEFAULT uuid_generate_v4(),
  name VARCHAR NOT NULL,
  email VARCHAR UNIQUE,
  phone VARCHAR,
  category_id UUID,
  FOREIGN KEY(category_id) REFERENCES categories(id)
);
```
---

# Aula 19

## Conectando o Node ao Postgres

- Instalar pacote: `yarn add pg` ou `npm install pg` ‚áí Pg √© um pacote que faz a ponte entre o node e o postgres
- Dentro da pasta **database** criar um arquivo *index.js*. Esse arquivo, ser√° respons√°vel por chamar o pacote pg e gerenciar as permiss√µes e informa√ß√µes pertinentes para o controle e acesso ao banco de dados

*index.js*

```jsx
const { Client } = require('pg');

const client = new Client({
  host: 'localhost',
  port: 5432,
  user: 'root',
  password: 'root',
  database: 'mycontacts'
});

client.connect();

exports.query = async (query) => {
  const { rows } = await client.query(query);
  return rows;
}
```

**EXPLICANDO:**

A `const client` define qual nosso banco de dados, acessando as configura√ß√µes de cria√ß√£o do banco, com a porta, o usu√°rio, a senha e o nome do banco.

Ao final do arquivo, ap√≥s a realiza√ß√£o da conex√£o, √© exportado um m√©todo para que possamos lidar com as queries SQL no nosso arquivo *repositories.js*

Notar que, a vari√°vel *rows* √© uma propriedade que existe dentro do objeto client.query. Essa propriedade √© o que nos permite trabalhar com os dados das tabelas existentes nos bancos de dados

---

# Aula 20

## Refatorando o m√©todo create

- Importar o arquivo index da pasta database:

```jsx
const db = require('../../database');
```

- O m√©todo create refatorado fica:

```jsx
async create({ name, email, phone, category_id }) {
    const [row] = await db.query(`
      INSERT INTO contacts(name, email, phone, category_id)
      VALUES($1, $2, $3, $4)
      RETURNING *
    `, [name, email, phone, category_id]);

    return row;
  }
```

---

# Aula 21

## Refatorando os m√©todos de find

- **REFATORANDO O FINDALL:**

**obs: Sempre que transformamos uma fun√ß√£o ou uma m√©todo de uma classe em *async* a mesma passa a retornar uma *Promise*.**

```jsx
async findAll() {
    const rows = await db.query('SELECT * FROM contacts');
    return rows;
  }
```

- **REFATORANDO O FIND BY ID:**

```jsx
async findById(id) {
    const [row] = await db.query('SELECT * FROM contacts WHERE id = $1', [id]);
    return row;
  }
```

- **REFATORANDO O FIND BY EMAIL:**

```jsx
async findByEmail(email) {
    const [row] = await db.query('SELECT * FROM contacts WHERE email = $1', [email]);
    return row;
  }
```
---

# Aula 22

## Ordenando os resultados do SELECT

Nessa aula vamos aprender a ordenar os resultados do SELECT. No caso, iremos ordenar a lista de contatos em ordem alfab√©tica pelo nome. Dessa vez, para fazermos a ordena√ß√£o das informa√ß√µes, iremos utilizar os recursos do pr√≥prio banco de dados:

Ajustando o m√©todo **findAll:**

```jsx
async findAll() {
    const rows = await db.query('SELECT * FROM contacts ORDER BY name ASC');
    return rows;
  }
```

Basicamente, dessa forma sempre iremos listar os contatos em ordem alfab√©tica pelo nome.

Para deixarmos essa ordena√ß√£o din√¢mica, em que o usu√°rio pode ajustar a ordem em que os contatos aparecem por uma *query param*, podemos fazer os seguintes reajustes:

Em ContactController.js, ajustando o m√©todo *index:*
Abaixo estamos pegando o QUERY PARAM *orderBy:*

```jsx
async index(request, response) {
    //lista todos os registros
    const { orderBy } = request.query;
    const contacts = await ContactRepository.findAll(orderBy);
    response.json(contacts);
  }
```

Agora, ajustando novamente o m√©todo *findAll* em ContactRepository.js:

```jsx
async findAll(orderBy = 'ASC') {
    const direction = orderBy.toUpperCase() === 'DESC' ? 'DESC' : 'ASC';
    const rows = await db.query(`SELECT * FROM contacts ORDER BY name ${direction}`);
    return rows;
  }
```

---

# Aula 23

---

# Aula 24

---

# Aula 25

---

# Aula 26

---

# Aula 27

---
