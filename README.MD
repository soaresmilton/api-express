# Node.JS com Expressüî•

Esse reposit√≥rio √© um breve resumo, com as principais informa√ß√µes retiradas do m√≥dulo 2 do curso [JSTACK](https://jstack.com.br/).

---
## Get in touch
Feito com ‚ù§Ô∏è by [**Milton Soares**](https://www.linkedin.com/in/soaresmilton/)

[![Linkedin Badge](https://img.shields.io/badge/linkedin-%230077B5.svg?&style=for-the-badge&logo=linkedin&logoColor=white&link=https://www.linkedin.com/in/soaresmilton/)](https://www.linkedin.com/in/soaresmilton/)
[![Youtube Badge](https://img.shields.io/badge/youtube-%23FF0000.svg?&style=for-the-badge&logo=youtube&logoColor=white)](https://www.youtube.com/channel/UCMsbUh0LDOMQCTBdBXwkFiQ/)
[![Instagram Badge](https://img.shields.io/badge/instagram-%23E4405F.svg?&style=for-the-badge&logo=instagram&logoColor=white&link=https://www.instagram.com/soaresmiltinho/)](https://www.instagram.com/soaresmiltinho/)
---

## Objetivo

Com a evolu√ß√£o do m√≥dulo, quero utilizar os conceitos aprendidos para desenvolver meu projeto chamado [getBooks](https://github.com/soaresmilton/getbooks)

---

### üìå√çndice

1. [Package Managers ‚Üí yarn and npm](#aula-1)

2. [Criando um servidor http com Express](#aula-2)

3. [Instalando o Nodemon](#aula-3)

4. [npm scripts](#aula-4)

5. [Configurando o Eslint e o editorconfig](#aula-5)

6. [Criando Controller de Contatos](#aula-6)

7. [Entendendo o Repository Pattern](#aula-7)

8. [Criando Repository de Contatos](#aula-8)

9. [Criando as rotas de show e delete](#aula-9)

10. [O que s√£o Middlewares?](#aula-10)

11. [Criando a rota de cadastro de Contatos](#aula-11)

12. [Criando a rota de edi√ß√£o dos Contatos](#aula-12)

13. [Aula13](#aula-13)

14. [Aula14](#aula-14)

15. [Aula15](#aula-15)

16. [Aula16](#aula-16)

17. [Aula17](#aula-17)

18. [Aula18](#aula-18)

19. [Aula19](#aula-19)

20. [Aula20](#aula-20)

21. [Aula21](#aula-21)

22. [Aula22](#aula-22)

23. [Aula23](#aula-23)

24. [Aula24](#aula-24)

25. [Aula25](#aula-25)

26. [Aula26](#aula-26)

27. [Aula27](#aula-27)

---

# Aula 1

## Package Managers - Npm and Yarn

### Tipos de m√≥dulo do Node.JS

- Nativos (ex.: *http, fs, os, URL*);
- Arquivos criados JavaScript;
- Node Package Manager (npm).

Instalando o node, j√° se instala o npm automaticamente.

O [Yarn](https://yarnpkg.com/) tamb√©m √© um Package Manager. Por√©m, com algumas funcionalidades melhoradas em rela√ß√£o ao NPM, tais como efici√™ncia na instala√ß√£o de pacotes e o arquivo *yarn.lock* que garante estabilidade em vers√µes futuras da aplica√ß√£o. Vale ressaltar que, atualmente, o npm tamb√©m tem a funcionalidade lock em suas features.

---

# Aula 2

## Criando um servidor http com Express

O objetivo dessa aula √© dar in√≠cio ao desenvolvimento da nossa API, que ser√° a base para a primeira aplica√ß√£o do curso, o **myContacts**. Para essa API, iremos utilizar alguns pacotes (ex.: express), que nos auxiliar√° na constru√ß√£o da API.

### Iniciando:

Para iniciar qualquer projeto node: `npm init -y` ou `yarn init`

**Instalando o express:**

`yarn add express`

### Desenvolvimento da aplica√ß√£o

1. `mkdir src && cd src && touch index.js`
2. Iniciar o servidor express. O nosso arquivo *index.js*:

    ```jsx
    const express = require('express');
    const app = express();

    const PORT = 3000;

    app.get('/', (request, response) => {
      response.send('<h1>Hello World</h1>')
    })

    app.listen(PORT, () => {
      console.log(`SERVER IS RUNING AT ===> http://localhost:${PORT}`);
    })
    ```

---

# Aula 3

## Instalando o Nodemon

O Nodemon √© um pacote de desenvolvimento, que nos auxilia na produtividade de constru√ß√µes de aplica√ß√£o com o Node.

Ele, por sua vez, fica "ouvindo" nosso servidor, fazendo com que n√£o precisemos reiniciar o servidor sempre que quisermos ver uma altera√ß√£o implementada.

**Instalando o nodemon como depend√™ncia de desenvolvimento:**

`yarn add nodemon -D`  ou `npm install nodemon -D`

**Usando o nodemon:**

`npx nodemon src/index.js`

---

# Aula 4
## Npm scripts

Os *npm's scripts* servem, basicamente, para duas coisas:

1. Fazer automa√ß√µes para processos e tarefas repetitivas
2. Atalhos para comandos longos e chatos de escrever

### Entendendo automa√ß√µes com npm scripts:

Para criar um novo npm script:

- No arquivo *package.json* criar um novo nodo chamado "scripts". Dentro desse nodo, especificar a chave, que ser√° o comando acionador do script e o valor dessa chave ser√° o comando node executado.
- No c√≥digo abaixo, vamos criar um script para iniciar nosso servidor.

```json
{
  "name": "express",
  "version": "1.0.0",
  "main": "index.js",
  "repository": "https://github.com/soaresmilton/api-express.git",
  "author": "Milton Soares <eng.milton.soares@gmail.com>",
  "license": "MIT",

  "scripts": {
    "dev": "nodemon src/index.js"
  },

  "dependencies": {
    "express": "^4.17.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.14"
  }
}

```

- No caso, o script substitui todo o comando: `nodemon src/index.js`, que n√≥s est√°vamos utilizando para iniciar um servidor, por `yarn dev` ou `npm run dev`.

---

# Aula 5
## Configurando o Eslint e o editorconfig

O Eslint √© uma ferramenta desenvolvida para padronizar a forma que escrevemos o c√≥digo, para manter ele limpo, organizado e padronizado ao longo do tempo. Esse tipo de ferramenta, garante que iremos ter consist√™ncia na digita√ß√£o do nosso c√≥digo, de forma a garantir, por exemplo, que sempre colocaremos ;, ou utilizaremos aspas simples para manusear strings.

**Iniciando a configura√ß√£o:**

1. Instalar a extens√£o ESLint no VSCODE
2. Instalar o pacote do ESLint no projeto:
    1. `yarn add eslint -D`
3. Acionar o comando de inicializa√ß√£o da ferramenta: `yarn eslint --init`. Ap√≥s executar o comando, algumas perguntas apareceram para a configura√ß√£o. Para esse projeto, responderemos:
    1. pergunta 1: Op√ß√£o 3
    2. Pergunta 2: Op√ß√£o 2
    3. Pergunta 3: Op√ß√£o 3
    4. Pergunta 4: No
    5. Pergunta 5: Node ‚Üí Primeiro apertar a tecla espa√ßo para desmarcar a op√ß√£o "browser" e selecionar a op√ß√£o Node para continuar.
    6. Pergunta 6: Op√ß√£o 1
    7. Pergunta 7: Op√ß√£o 1 - Style Guide do Airbnb
    8. Pergunta 8: Op√ß√£o 1
    9. Pergunta 9: yes

    Ap√≥s a configura√ß√£o, rodar o comando yarn no terminal para o Yarn reconhecer o eslint tamb√©m.


### Editorconfig

A segunda ferramenta de configura√ß√µes que iremos utilziar √© o EditorConfig for VS Code. Da mesma forma, devemos instalar essa extens√£o no nosso editor de texto.

**Usando o editorconfig**

1. Na parte *explorer,* onde mostra a estrutura de arquivos do nosso editor de texto, clicar com o bot√£o direito do mouse e selecionar a op√ß√£o: ***Generate .editorconfig***
2. Isso vai criar um documento *.editorconfig* com algumas configura√ß√µes pr√© determinadas

    ```jsx
    # EditorConfig is awesome: https://EditorConfig.org

    # top-most EditorConfig file
    root = true

    [*]
    indent_style = space
    indent_size = 2
    end_of_line = lf
    charset = utf-8
    trim_trailing_whitespace = true //vem false como padr√£o
    insert_final_newline = true // vem false como padr√£o
    ```

---

# Aula 6

## Criando Controller de Contatos

**Defini√ß√£o de controller**

Um *controller* atua como um centralizador de funcionalidades ou regras de neg√≥cio de uma determinada entidade de nossa aplica√ß√£o.

Como a API a ser constru√≠da ser√° relacionados a gerenciamento de contatos, portanto iremos criar um controller espec√≠fico para os contatos.

**Iniciando nossa estrutura:**

- Em src, criar uma pasta app, em app criar a pasta controllers.
    - A pasta controllers ser√° nosso local de cria√ß√£o dos controllers para cada entidade que nossa aplica√ß√£o necessitar;
    - Resumindo: `cd src && mkdir app && cd app && mkdir controllers && cd controllers && touch ContactController.js`

    Estrutura de pastas nesse ponto da aplica√ß√£o:

    ![Arquitetura de pastas do nosso projeto at√© o momento](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a636e647-87c9-402a-a01d-039740a3cf8e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20211028%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211028T010122Z&X-Amz-Expires=86400&X-Amz-Signature=c6847af7944c723aba3ba1188bb9187182eef8b5b8a9980c55049120a58fa1e2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)


    Arquitetura do nosso projeto at√© o momento. Destacando o controller criado

- Nos controllers, vamos implement√°lo utilizando classes e iremos utilizar um Design Pattern chamado de Singleton. Esse pattern diz que podemos ter apenas uma √∫nica instancia do objeto em nosso app.
- Para os m√©todos da nossa classe referente ao Controller, iremos abordar seus m√©todos usando uma conven√ß√£o padr√£o, em que os m√©todos:
    - index() ‚áí Usado para listar todos os registros do Controller;
    - show() ‚áí Usado para obter somente um registro;
    - store() ‚áí Cria novo registro
    - update() ‚áí Edita um registro
    - delete() ‚áí Deleta um registro
- Continuando ‚áí Mover nossas rotas criadas no arquivo *index.js*  para um novo arquivo chamado *routes.js* criado dentro da pasta src.

    Nosso arquivo routes.js dever√° ficar dessa maneira:

    ```jsx
    const { Router } = require('express');
    const router = Router();
    const ContactController = require('./app/controllers/ContactController');

    router.get('/contacts', ContactController.index);

    module.exports = router;
    ```

    O arquivo index.js:

    ```jsx
    const express = require("express");
    const routes = require('./routes');
    const app = express();

    const PORT = 3000;

    app.use(routes);

    app.listen(PORT, () => {
      console.log(`SERVER IS RUNING AT ===> http://localhost:${PORT}`);
    });
    ```

    O arquivo ContactController.js

    ```jsx
    class ContactController {
      index(request, response) {
        //lista todos os registros
        response.send('Sendo from Contact Controller')
      }

      show() {
        //obter um registro
      }

      store() {
        //Criar novo registro
      }

      update() {
        //Editar um registro
      }

      delete() {
        // Deletar um registro
      }
    }

    //Design Pattern: Singleton => Podemos ter apenas uma √∫nica inst√¢ncia desse objeto no app
    module.exports = new ContactController();
    ```

---

# Aula 7

## Entendendo o Repository Pattern

**Defini√ß√£o:**
Repository Pattern √© uma layer (camada) de abstra√ß√£o de acesso ao Data Source (fonte de dados, que pode ser: SQL, NoSQL, .json, API).

**Vantagens de usar o Repository Pattern:**

O repository pattern tira a obriga√ß√£o de implementar dados sens√≠veis, como a regra de neg√≥cio principal da aplica√ß√£o, dentro de um controller. Consequentemente, deixa o c√≥digo mais f√°cil de se manter a longo prazo, bem como seguro contra erros de l√≥gica e implementa√ß√£o.

Exemplo: caso em algum momento do desenvolvimento da aplica√ß√£o, necessite trocar o banco de dados SQL para um NoSQL, podemos refatorar somente o repository, sem fazer altera√ß√µes sens√≠veis no controller

Dessa forma, a arquitetura b√°sica desse pattern fica:

`Controller ‚Üî Repository ‚Üî Data Source`

Sendo assim, o Controller n√£o tem interesse em como o repository ir√° criar seus m√©todos para cria√ß√£o de entidades dentro da aplica√ß√£o.

---

# Aula 8

## Criando Repository de Contatos

**Iniciando:**

- Criar pasta *repositories* dentro da pasta app.
- Criar arquivo repository da entidade em quest√£o. Nesse caso, criar o arquivo *ContactRepository.*
- Nessa aplica√ß√£o, tamb√©m iremos usar o pattern Singleton para exportar o ContactRepository como uma classe instanciada.
- Na classe instanciada, iremos criar todos os m√©todos que o repository necessita para manipular o data source.
- Iremos iniciar a aplica√ß√£o com um Data Source mocado, para que futuramente, possamos entender o sentido de usar o Repository Pattern na pr√°tica, refatorando o repository e migrando o Data Source para o PostgreSQL
- Instalar a lib *uuidv4* para gerar hashs para nosso ID ser uma string alfanum√©rica ‚Üí melhora a seguran√ßa de nossos dados; `yarn add uuid`
- Cria o mock no proprio arquivo do repository, sendo que o mock √© um array de objetos.
- Agora, implementamos uma l√≥gica bem simples para retornar a lista de contatos: criar metodo findAll em nossa classe **ContactRepository** que simplesmenre retorna os contatos. Ap√≥s isso, importar o repository no controller e chamar o m√©todo ContactRepository.findAll() no m√©todo index();

    Nesse ponto, nossos arquivos *ContactRepository.js* e *ContactRepository.js* ficaram dessa maneira:

    *ContactRepository:*

    ```jsx
    const { uuid } = require('uuidv4');
    const contacts = [
      {
        id: uuid(),
        name: 'Milton',
        email: 'milton@gmail.com',
        phone: '3555555555',
        category_id: uuid(),
      },
    ]

    class ContactRepository {
      // Listar todos os registros do reposit√≥rio
      findAll() {
        return contacts;
      }
    }

    module.exports = new ContactRepository();
    ```

    *ContactRepository:*

    ```jsx
    const ContactRepository = require('../repositories/ContactRepository');

    class ContactController {
      async index(request, response) {
        //lista todos os registros
        const contacts = await ContactRepository.findAll();
        response.json(contacts);
      }

      show() {
        //obter um registro
      }

      store() {
        //Criar novo registro
      }

      update() {
        //Editar um registro
      }

      delete() {
        // Deletar um registro
      }
    }

    //Design Pattern: Singleton => Podemos ter apenas uma √∫nica inst√¢ncia desse objeto no app
    module.exports = new ContactController();
    ```

- Nesse ponto √© importante observar que, quando tivermos conectados a um banco de dados, a chamada dos dados do banco para que seja poss√≠vel listar os contatos na tela, √© uma fun√ß√£o bloqueante devido ao tempo de resposta do banco de dados. Ent√£o, temos que transformar o m√©todo findAll em uma promise JS e utilizar o conceito de async / await no m√©todo index() do Contact Controller.  Veja na pr√°tica:


    ```jsx
    const { v4 } = require('uuidv4');
    const contacts = [
      {
        id: v4(),
        name: 'Milton',
        email: 'milton@gmail.com',
        phone: '3555555555',
        category_id: v4(),
      },
    ]

    class ContactRepository {
      // Listar todos os registros do reposit√≥rio
      findAll() {
        return new Promise((resolve) => resolve(contacts));
      }
    }

    module.exports = new ContactRepository();
    ```

---

# Aula 9

## Criando as rotas de show e delete

Nessa aula iremos implementar os m√©todos show e delete. Aprenderemos a como receber par√¢metros nas rotas com o express e dar continuidade no desenvolvimento de nossa API.

**M√©todo SHOW:**

- No arquivo routes.js, criar a rota para o show. Nesse ponto, nosso arquivo de rotas vai ficar dessa maneira:

    ```jsx
    const { Router } = require('express');
    const router = Router();
    const ContactController = require('./app/controllers/ContactController');

    router.get('/contacts', ContactController.index);
    router.get('/contacts/:id', ContactController.show);

    module.exports = router;
    ```

- Uma vez criado a rota que recebe o param desejado na URL, podemos implementar os m√©todos no Controller e no repository. Para o Controller, por conven√ß√£o, implementaremos o m√©todo *show()*. A implementa√ß√£o desse m√©todo fica:

    ```jsx
    async show(request, response) {
        //obter um registro
        const { id } = request.params;
        const contact = await ContactRepository.findById(id);

        if (!contact) return response.status(404).json({ error: 'Contact not found' });

        response.json(contact);
      }
    ```

- Agora, devemos impelemntar o m√©todo **findById()** dentro do nosso repository. √â esse m√©todo que de fato encontra o contato pelo seu ID. Aqui, j√° conseguimos enchergar melhor um pouco mais da ideia por tr√°s o Repository Pattern. Sendo assim, a implementa√ß√£o do m√©todo *findById()* fica:

    ```jsx
    findById(id) {
        return new Promise((resolve) => resolve(
          contacts.find((contact) => contact.id === id)
        ));
      }
    ```


**M√âTODO DELETE:**

- Criar rota delete no arquivo de rotas;

    ```jsx
    router.delete('/contacts/:id', ContactController.delete);
    ```

- Implementar o m√©todo delete no Controller

    ```jsx
    async delete(request, response) {
        // Deletar um registro
        const { id } = request.params;

        const contact = await ContactRepository.findById(id);
        if (!contact) return response.status(404).json({ error: 'Contact not found' });

        await ContactRepository.delete(id);
        response.sendStatus(204); // 204: No content
      }
    ```

- Implementar o m√©todo delete do Repository:

    ```jsx
    delete(id) {
        return new Promise((resolve) => {
          contacts  = contacts.filter((contact) => contact.id !== id)
          resolve();
        })
      }
    ```

---

# Aula 10
## O que s√£o Middlewares?

**Como funciona o life cycle de uma request:**

Toda vez que uma request "chega" a API precisa resolver essa requisi√ß√£o. E pra resolver essa requisi√ß√£o n√≥s chamamos um m√©todo de um Controller, que √© onde est√° localizado nossa regra de neg√≥cio. Ao fim da resolu√ß√£o de nossa request, n√≥s respondemos alguma coisa, enviando uma response (seja um sucesso ou um erro).

>Request ‚Üí Repository ‚Üí Controller ‚Üí response

**Com os Middlewares**

Os middlewares,  manipulam os objetos *request* e *response*. Fazendo todas as a√ß√µes necess√°rias nesses objetos, inclusive inserindo novas propriedades a eles e disponibilizando para todos os controllers  da aplica√ß√£o. Ou at√© mesmo executando para coisas espec√≠ficas para uma determinada rota ou determinado controller.

Outra funcionalidade dos middlewares √© poder controlar o life cycle do request. Como assim?

Essencialmente,  os middlewares antecipam uma request, antes dessa request chegar ao Controller. Dessa forma, os middlewares conseguem responder alguma coisa para a request caso seja necess√°rio. Sendo assim, conseguem decidir se a request continuar√° o caminho de execu√ß√£o "normal", sendo enviada para o Controller resolver a request ou se a requisi√ß√£o ser√° interrompida e alguma resposta ser√° retornada para a pr√≥pria request.

>Request ‚Üî Repository ‚Üí Controller - response

**Caso de uso commum:**

- Autentica√ß√£o ‚Üí valida√ß√£o de usu√°rio.

---

# Aula 11
## Criando a rota de cadastro de Contatos

- Primeiro passo criar rota com m√©todo POST no arquivo routes.js:

    ```jsx
    router.post('/contacts', ContactController.store);
    ```

- Chamar o m√©todo (middleware) json no arquivo index.js:

    ```jsx
    app.use(json());
    ```

- Implementar os m√©todos que ir√£o fazer o registro das informa√ß√µes. Nesse caso, no Controller, o m√©todo usado executar a cria√ß√£o de contatos √© o store(). No Repository, os m√©todos utilizados s√£o chamados de findByEmail() - que verifica se o email j√° foi cadastrado anteriormente e o create() ‚Üí que necessariamente √© usado para criar o contato.

    **M√©todo store() ‚Üí no Controller**

    ```jsx
    async store(request, response) {
        //Criar novo registro
        const { name, email, phone, category_id } = request.body;

        if(!name) {
          return response.status(400).json({ error: 'Name is required' });
        }

        const contactExists = await ContactRepository.findByEmail(email);
        if (contactExists) {
          return response.status(400).json({ error: 'This email already been taken' })
        }

        const contact = await ContactRepository.create({
          name, email, phone, category_id
        });

        response.json(contact)
      }
    ```

    **M√©todo findByEmail() - No Repository:**

    ```jsx
    findByEmail(email) {
        return new Promise((resolve) => resolve(
          contacts.find((contact) => contact.email === email)
        ));
      }
    ```

    **M√©todo create() - no repository**

    ```jsx
    create({name, email, phone, category_id}) {
        return new Promise((resolve) => {
          const newContact = {
            id: v4(),
            name,
            email,
            phone,
            category_id: v4()
          }

          contacts.push(newContact)
          resolve(newContact);
        })
      }
    ```
---

# Aula 12

## Criando a rota de edi√ß√£o dos Contatos

Para finalizarmos a primeira parte de nossa API, falta construir nossa rota de edi√ß√£o de contatos.

Para isso, seguimos:

- Criando a rota com m√©todo HTTP do tipo PUT. em *routes.js*:

```jsx
router.put('/contacts/:id', ContactController.update);
```

- Implementando o m√©todo update no Controller. Em *ContactController.js:*

```jsx
async update(request, response) {
    //Editar um registro
    const { id } = request.params;
    const { name, email, phone, category_id } = request.body;

    const contactExists = await ContactRepository.findById(id);
    if (!contactExists) return response.status(404).json({ error: 'User not found' });

    if (!name) return response.status(400).json({ error: 'Name is required' });

    const contactByEmail = await ContactRepository.findByEmail(email);
    if (contactByEmail && contactByEmail.id !== id) return response.status(400).json({ error: 'This e-mail is already in use' });

    const contact = await ContactRepository.update(id, {
      name, email, phone, category_id
    });

    response.json(contact);
  }
```

- Implementar o m√©todo update no Repository: Em *ContactRepository.js:*

```jsx
update(id, {
    name, email, phone, category_id,
  }) {
    return new Promise((resolve) => {
      const updatedContact = {
        id,
        name,
        email,
        phone,
        category_id,
      };

      contacts = contacts.map((contact) => (
        contact.id === id ? updatedContact : contact
      ));

      resolve(updatedContact);
    });
  }
```

---

# Aula 13

---

# Aula 14

---

# Aula 15

---

# Aula 16

---

# Aula 17

---

# Aula 18

---

# Aula 19

---

# Aula 20

---

# Aula 21

---

# Aula 22

---

# Aula 23

---

# Aula 24

---

# Aula 25

---

# Aula 26

---

# Aula 27

---
